#version 450 core

layout(set = 1, binding = 0, rgba32f) uniform readonly image2D imageNormalDepth;
layout(set = 1, binding = 1, rgba32f) uniform readonly image2D imagePositionMaterial;
layout(set = 1, binding = 2, rgba16f) uniform writeonly image2D imageLight;

__INJECT_ENVIRONMENT__
__INJECT_CONSTANTS__
__INJECT_INSTANCES__
__INJECT_MATERIALS__

layout(local_size_x = 32, local_size_y = 32) in;
void main() {
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);

    const vec4 normalDepth      = imageLoad(imageNormalDepth, pos);
    const vec4 positionMaterial = imageLoad(imagePositionMaterial, pos);

    vec4 color = vec4(0);

    const vec3 backgroundColor = vec3(1., 163., 236.) / vec3(500);
    const vec3 sunDir          = normalize(vec3(1, 1, 1));

    if (normalDepth.w < MAX_DISTANCE) {
        vec3 materialColor = materials[floatBitsToUint(positionMaterial.w)].color.xyz;
        
        color = vec4(materialColor, 1.0);
        float intensity = max(0, dot(normalDepth.xyz, sunDir));
    
        if (intensity > 0.95)      color *= vec4(1.0, 1.0, 1.0, 1.0);
        else if (intensity > 0.75) color *= vec4(0.8, 0.8, 0.8, 1.0);
        else if (intensity > 0.50) color *= vec4(0.6, 0.6, 0.6, 1.0);
        else if (intensity > 0.25) color *= vec4(0.4, 0.4, 0.4, 1.0);
        else                       color *= vec4(0.2, 0.2, 0.2, 1.0);

        vec3 normal;
        float sunRay = trace(positionMaterial.xyz + normalDepth.xyz * EPSILON, sunDir, normal);
        if (sunRay != MAX_DISTANCE) {
            color = color * 0.08;
        }
        
    } else {  
        color = vec4(backgroundColor + abs(1.0 - normalDepth.y) * 0.4, 1.0);
    }

    imageStore(imageLight, pos, color);
}